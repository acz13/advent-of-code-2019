k=require('fs').readFileSync(0, 'utf-8');a=k.trim().split("\n").map(l => l.split(""));l=a.length;m=a[0].length;d=[[-1,0],[0,-1],[1,0],[0,1]];s=0;low=[];b=new Set();function* neighbors(i, j) { for (const [di, dj] of d) { if (i + di < l && i + di > -1 && j + dj < m && j + dj > -1 && !b.has(1000*(i+di)+j+dj)) yield [i+di, j+dj] } };for (let i = 0; i < l; i++) { for (let j = 0; j < m; j++) { e=Infinity;for (const [_i, _j] of neighbors(i, j)) { e=Math.min(e,+a[_i][_j]) } if (+a[i][j] < e) { s += +a[i][j] + 1; low.push([i, j]) } } };console.log("Part 1:", s);y=[];for (const [i, j] of low) { f=[...neighbors(i, j)]; b=new Set(); while (f.length) { const [i,j]=f.pop(); if (!b.has(1000*i+j) && +a[i][j] !== 9) { b.add(1000*i+j); f.push(...neighbors(i,j)) } } y.push(b.size) };y.sort((x,y)=>x-y);console.log("Part 2:", y.slice(y.length-3, y.length).reduce((x,y)=>x*y))
